<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Turn-Based Strategy Game - Live Viewer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #fdf6e3; /* Solarized light base3 */
            color: #657b83; /* Solarized light base00 */
            overflow: hidden;
            height: 100vh;
        }

        .container {
            display: flex;
            height: 100vh;
            width: 100vw;
        }

        .game-area {
            flex: 1;
            display: flex;
            flex-direction: column;
            position: relative;
        }

        .header {
            background: rgba(238, 232, 213, 0.9); /* Solarized light base2 with transparency */
            backdrop-filter: blur(10px);
            padding: 15px 25px;
            border-bottom: 2px solid rgba(147, 161, 161, 0.3); /* Solarized light base1 */
        }

        .header h1 {
            font-size: 24px;
            font-weight: 300;
            margin-bottom: 5px;
            color: #586e75; /* Solarized light base01 */
        }

        .game-info {
            display: flex;
            gap: 30px;
            font-size: 14px;
            opacity: 0.9;
        }

        .info-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .status-indicator {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #859900; /* Solarized green */
            animation: pulse 2s infinite;
        }

        .status-indicator.disconnected {
            background: #dc322f; /* Solarized red */
        }

        .status-indicator.waiting {
            background: #b58900; /* Solarized yellow */
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .canvas-container {
            flex: 1;
            position: relative;
            background: rgba(147, 161, 161, 0.1); /* Solarized light base1 */
        }

        #gameCanvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        .sidebar {
            width: 300px;
            background: rgba(238, 232, 213, 0.8); /* Solarized light base2 */
            backdrop-filter: blur(15px);
            border-left: 2px solid rgba(147, 161, 161, 0.3); /* Solarized light base1 */
            display: flex;
            flex-direction: column;
        }

        .sidebar-section {
            padding: 20px;
            border-bottom: 1px solid rgba(147, 161, 161, 0.3); /* Solarized light base1 */
        }

        .sidebar-section h3 {
            font-size: 16px;
            font-weight: 500;
            margin-bottom: 15px;
            color: #586e75; /* Solarized light base01 */
        }

        .player-list {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .player-card {
            background: rgba(147, 161, 161, 0.1); /* Solarized light base1 */
            border-radius: 8px;
            padding: 12px;
            border-left: 4px solid #93a1a1; /* Solarized light base1 */
            transition: all 0.3s ease;
        }

        .player-card.active {
            background: rgba(147, 161, 161, 0.2); /* Solarized light base1 */
            transform: translateY(-1px);
        }

        .player-card.eliminated {
            opacity: 0.6;
            background: rgba(220, 50, 47, 0.1); /* Solarized red */
            border-left-color: #dc322f; /* Solarized red */
        }

        .player-card.winner {
            background: rgba(181, 137, 0, 0.2); /* Solarized yellow */
            border-left-width: 6px;
            transform: translateX(2px);
            box-shadow: 0 2px 8px rgba(181, 137, 0, 0.3);
        }

        .player-name {
            font-weight: 500;
            font-size: 14px;
            margin-bottom: 4px;
        }

        .player-stats {
            font-size: 12px;
            opacity: 0.8;
            display: flex;
            justify-content: space-between;
        }

        .player-status {
            font-size: 11px;
            padding: 2px 6px;
            border-radius: 10px;
            background: rgba(133, 153, 0, 0.2); /* Solarized green */
            color: #859900; /* Solarized green */
        }

        .player-status.eliminated {
            background: rgba(220, 50, 47, 0.2); /* Solarized red */
            color: #dc322f; /* Solarized red */
        }

        .player-status.disconnected {
            background: rgba(181, 137, 0, 0.2); /* Solarized yellow */
            color: #b58900; /* Solarized yellow */
        }

        .game-log {
            flex: 1;
            padding: 20px;
            overflow-y: auto;
        }

        .log-entry {
            font-size: 12px;
            padding: 6px 0;
            border-bottom: 1px solid rgba(147, 161, 161, 0.1); /* Solarized light base1 */
            opacity: 0.8;
        }

        .log-entry.elimination {
            color: #dc322f; /* Solarized red */
            font-weight: 500;
        }

        .log-entry.game-event {
            color: #859900; /* Solarized green */
            font-weight: 500;
        }

        .log-entry.turn-data {
            color: #b58900; /* Solarized yellow */
            font-weight: 500;
        }


        .game-over-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(253, 246, 227, 0.9); /* Solarized light base3 */
            backdrop-filter: blur(10px);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 200;
        }

        .game-over-content {
            background: rgba(238, 232, 213, 0.9); /* Solarized light base2 */
            border-radius: 15px;
            padding: 40px;
            text-align: center;
            max-width: 500px;
            border: 2px solid rgba(147, 161, 161, 0.3); /* Solarized light base1 */
        }

        .game-over-content h2 {
            font-size: 36px;
            margin-bottom: 20px;
            background: linear-gradient(45deg, #b58900, #cb4b16); /* Solarized yellow to orange */
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .winner-list {
            font-size: 18px;
            margin-bottom: 20px;
        }

        .rankings {
            text-align: left;
            margin-top: 20px;
        }

        .ranking-item {
            padding: 8px 0;
            border-bottom: 1px solid rgba(147, 161, 161, 0.3); /* Solarized light base1 */
        }


        @media (max-width: 768px) {
            .container {
                flex-direction: column;
            }
            
            .sidebar {
                width: 100%;
                max-height: 300px;
            }
            
            .game-area {
                order: -1;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="game-area">
            <div class="header">
                <h1>Turn-Based Strategy Game</h1>
                <div class="game-info">
                    <div class="info-item">
                        <span class="status-indicator" id="connectionStatus"></span>
                        <span id="connectionText">Connecting...</span>
                    </div>
                    <div class="info-item">
                        <span>Turn:</span>
                        <span id="currentTurn">-</span>
                    </div>
                    <div class="info-item">
                        <span>Status:</span>
                        <span id="gameStatus">Waiting</span>
                    </div>
                </div>
            </div>
            
            <div class="canvas-container">
                <canvas id="gameCanvas"></canvas>
            </div>
            
            <div class="game-over-overlay" id="gameOverOverlay">
                <div class="game-over-content">
                    <h2>Game Over!</h2>
                    <div class="winner-list" id="winnerList"></div>
                    <div class="rankings" id="finalRankings"></div>
                </div>
            </div>
        </div>
        
        <div class="sidebar">
            <div class="sidebar-section">
                <h3>Players</h3>
                <div class="player-list" id="playerList">
                    <!-- Players will be populated here -->
                </div>
            </div>
            
            <div class="sidebar-section">
                <h3>Game Log</h3>
            </div>
            
            <div class="game-log" id="gameLog">
                <!-- Log entries will be populated here -->
            </div>
        </div>
    </div>

    <script>
        class GameViewer {
            constructor() {
                this.socket = null;
                this.gameState = null;
                this.gameId = this.getGameIdFromURL();
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.playerColors = {};
                this.colorPalette = [
                    '#dc322f', '#268bd2', '#859900', '#b58900', 
                    '#6c71c4', '#2aa198', '#cb4b16', '#d33682'
                ];
                this.colorIndex = 0;
                this.previousPlayers = new Map(); // Track previous player states
                
                // Animation system
                this.isAnimating = false;
                this.animationData = null;
                this.turnDuration = 1000; // Default 1 second, will be updated
                this.lastRenderTime = 0;
                this.animationStartTime = 0;
                this.currentPhase = 'idle'; // 'movement', 'state_change', 'generation', 'idle'
                
                // Animation states
                this.displayedVertices = new Map(); // Current displayed state
                this.targetVertices = new Map(); // Target state after animations
                this.movingUnits = []; // Units currently animating
                this.unitGenerationAnimations = []; // +Weight text animations
                
                
                this.setupCanvas();
                this.updateUIWithGameId();
                this.connectToServer();
                this.setupResizeHandler();
                this.startRenderLoop();
            }

            getGameIdFromURL() {
                const urlParams = new URLSearchParams(window.location.search);
                return urlParams.get('game') || 'default';
            }
            
            updateUIWithGameId() {
                // Update page title and header to show game ID (hide "default" for cleaner UI)
                const isDefaultGame = this.gameId === 'default';
                const titleText = isDefaultGame ? 'Turn-Based Strategy Game' : `Turn-Based Strategy Game - ${this.gameId}`;
                
                document.title = titleText;
                const header = document.querySelector('h1');
                if (header) {
                    header.textContent = titleText;
                }
                
                // Update game ID display (show "default" in the info area but not in title)
                const gameIdElement = document.getElementById('gameId');
                if (gameIdElement) {
                    gameIdElement.textContent = this.gameId;
                }
            }

            startRenderLoop() {
                const render = (timestamp) => {
                    this.lastRenderTime = timestamp;
                    this.updateAnimations(timestamp);
                    this.renderFrame();
                    requestAnimationFrame(render);
                };
                requestAnimationFrame(render);
            }

            updateAnimations(timestamp) {
                if (!this.isAnimating || !this.animationData) {
                    return;
                }
                
                const elapsed = timestamp - this.animationStartTime;
                const progress = elapsed / this.turnDuration;
                
                // Phase timings (as percentages of turn duration)
                const movementEnd = 0.30;
                const stateChangeEnd = 0.35; // Very brief instant snap
                const generationEnd = 0.70;
                
                
                if (progress <= movementEnd) {
                    this.currentPhase = 'movement';
                    this.updateMovementAnimation(progress / movementEnd);
                } else if (progress <= stateChangeEnd) {
                    if (this.currentPhase === 'movement') {
                        this.finishMovementPhase();
                        this.setupStateChangePhase();
                        this.currentPhase = 'state_change';
                    }
                    // State change is instant - no animation needed
                } else if (progress <= generationEnd) {
                    if (this.currentPhase === 'state_change') {
                        this.finishStateChangePhase();
                        this.currentPhase = 'generation';
                        this.startGenerationAnimations();
                    }
                    this.updateGenerationAnimation((progress - stateChangeEnd) / (generationEnd - stateChangeEnd));
                } else {
                    // Animation complete
                    this.finishGenerationPhase();
                    this.finishAnimation();
                }
            }
            
            setupStateChangePhase() {
                // Calculate what the vertex states should be after movement but before generation
                if (!this.animationData || !this.targetVertices) return;
                
                this.targetVertices.forEach((targetVertex, vertexId) => {
                    const displayVertex = this.displayedVertices.get(vertexId);
                    if (!displayVertex) return;
                    
                    // Calculate the pre-generation state (final state minus weight increment)
                    let preGenerationUnits = targetVertex.units;
                    
                    // If this vertex generates units, subtract the weight from the target
                    if (this.animationData.unit_generation) {
                        const generatesUnits = this.animationData.unit_generation.find(gen => gen.vertex_id === vertexId);
                        if (generatesUnits && targetVertex.controller) {
                            preGenerationUnits -= (targetVertex.weight || 1);
                        }
                    }
                    
                    // Store the pre-generation state
                    displayVertex.preGenerationUnits = preGenerationUnits;
                    displayVertex.preGenerationController = targetVertex.controller;
                });
            }

            updateMovementAnimation(progress) {
                
                // Update positions of moving units
                this.movingUnits.forEach(unit => {
                    const easedProgress = this.easeInOutCubic(progress);
                    unit.currentX = unit.startX + (unit.endX - unit.startX) * easedProgress;
                    unit.currentY = unit.startY + (unit.endY - unit.startY) * easedProgress;
                    unit.alpha = 1.0 - (progress * 0.3); // Slightly fade during movement
                });
            }

            updateStateChangeAnimation(progress) {
                // Animate color transitions for vertices that changed ownership
                const easedProgress = this.easeInOutCubic(progress);
                
                this.displayedVertices.forEach((displayVertex, vertexId) => {
                    const targetVertex = this.targetVertices.get(vertexId);
                    if (!targetVertex) return;
                    
                    // Animate controller change
                    if (displayVertex.controller !== targetVertex.controller) {
                        displayVertex.controllerTransition = easedProgress;
                        displayVertex.newController = targetVertex.controller;
                    }
                });
            }

            startGenerationAnimations() {
                // Initialize +Weight text animations
                this.unitGenerationAnimations = [];
                
                if (this.animationData && this.animationData.unit_generation) {
                    this.animationData.unit_generation.forEach(genData => {
                        const displayVertex = this.displayedVertices.get(genData.vertex_id);
                        if (displayVertex) {
                            // Get vertex position for the animation
                            const vertexPos = this.getVertexScreenPosition(genData.vertex_id);
                            if (vertexPos) {
                                this.unitGenerationAnimations.push({
                                    vertexId: genData.vertex_id,
                                    weight: displayVertex.weight || 1,
                                    x: vertexPos.x,
                                    y: vertexPos.y,
                                    startTime: 0, // Will be set relative to generation phase
                                    alpha: 1.0,
                                    offsetY: 0
                                });
                            }
                        }
                    });
                }
            }

            updateGenerationAnimation(progress) {
                // Animate unit count increases from pre-generation to final state
                const easedProgress = this.easeInOutCubic(progress);
                
                if (this.animationData && this.animationData.unit_generation) {
                    this.animationData.unit_generation.forEach(genData => {
                        const displayVertex = this.displayedVertices.get(genData.vertex_id);
                        const targetVertex = this.targetVertices.get(genData.vertex_id);
                        
                        if (displayVertex && targetVertex && displayVertex.preGenerationUnits !== undefined) {
                            const startUnits = displayVertex.preGenerationUnits;
                            const endUnits = targetVertex.units;
                            displayVertex.units = Math.floor(startUnits + (endUnits - startUnits) * easedProgress);
                        }
                    });
                }
                
                // Update +Weight text animations
                this.unitGenerationAnimations.forEach(anim => {
            
            
                    // Float upward and fade out
                    anim.offsetY = (this.easeInOutCubic(1.0 - progress) * -10) -30; // Move up 40 pixels
                    anim.alpha = this.easeInOutCubic(1.0 - progress); // Fade out completely
                });
            }

            getVertexScreenPosition(vertexId) {
                if (!this.gameState || !this.gameState.graph) return null;
                
                const canvas = this.canvas;
                const rect = canvas.getBoundingClientRect();
                const width = rect.width;
                const height = rect.height;
                const vertices = this.gameState.graph.vertices;
                
                if (vertices.length === 0) return null;
                
                const vertex = vertices.find(v => v.id === vertexId);
                if (!vertex) return null;
                
                const minX = Math.min(...vertices.map(v => v.position[0]));
                const maxX = Math.max(...vertices.map(v => v.position[0]));
                const minY = Math.min(...vertices.map(v => v.position[1]));
                const maxY = Math.max(...vertices.map(v => v.position[1]));
                
                const graphWidth = maxX - minX;
                const graphHeight = maxY - minY;
                
                const padding = 60;
                const scale = Math.min(
                    (width - 2 * padding) / (graphWidth || 1),
                    (height - 2 * padding) / (graphHeight || 1)
                );
                
                const offsetX = (width - graphWidth * scale) / 2 - minX * scale;
                const offsetY = (height - graphHeight * scale) / 2 - minY * scale;
                
                return {
                    x: vertex.position[0] * scale + offsetX,
                    y: vertex.position[1] * scale + offsetY
                };
            }

            finishMovementPhase() {
                // Clear moving units and update source vertices
                this.movingUnits.forEach(unit => {
                    const sourceVertex = this.displayedVertices.get(unit.fromVertex);
                    if (sourceVertex) {
                        sourceVertex.units = Math.max(0, sourceVertex.units - unit.units - unit.cost);
                    }
                });
                this.movingUnits = [];
            }

            finishStateChangePhase() {
                // Instantly snap to post-movement, pre-generation state
                this.displayedVertices.forEach((displayVertex, vertexId) => {
                    if (displayVertex.preGenerationUnits !== undefined) {
                        displayVertex.units = displayVertex.preGenerationUnits;
                        displayVertex.controller = displayVertex.preGenerationController;
                        
                        // Clear transition states
                        displayVertex.controllerTransition = undefined;
                        displayVertex.newController = undefined;
                    }
                });
            }
            
            finishGenerationPhase() {
                // Ensure all units are at final values and clear temporary states
                this.displayedVertices.forEach((displayVertex, vertexId) => {
                    const targetVertex = this.targetVertices.get(vertexId);
                    if (targetVertex) {
                        displayVertex.units = targetVertex.units;
                        displayVertex.controller = targetVertex.controller;
                        // Clear all temporary animation states
                        displayVertex.baseUnits = undefined;
                        displayVertex.preGenerationUnits = undefined;
                        displayVertex.preGenerationController = undefined;
                    }
                });
                
                // Clear generation animations
                this.unitGenerationAnimations = [];
            }

            finishAnimation() {
                this.isAnimating = false;
                this.animationData = null;
                this.currentPhase = 'idle';
                this.movingUnits = [];
                this.unitGenerationAnimations = [];
                
                // Update the game state to match final values
                if (this.gameState && this.gameState.graph) {
                    this.gameState.graph.vertices.forEach(vertex => {
                        const displayVertex = this.displayedVertices.get(vertex.id);
                        if (displayVertex) {
                            vertex.units = displayVertex.units;
                            vertex.controller = displayVertex.controller;
                        }
                    });
                }
                
            }

            easeInOutCubic(t) {
                return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
            }

            easeOutCubic(t) {
                return 1 - Math.pow(1 - t, 3);
            }

            getVertexPosition(vertexId, scale, offsetX, offsetY) {
                if (!this.gameState || !this.gameState.graph) return null;
                
                const vertex = this.gameState.graph.vertices.find(v => v.id === vertexId);
                if (!vertex) return null;
                
                return {
                    x: vertex.position[0] * scale + offsetX,
                    y: vertex.position[1] * scale + offsetY
                };
            }

            setupCanvas() {
                const resizeCanvas = () => {
                    const container = this.canvas.parentElement;
                    const rect = container.getBoundingClientRect();
                    
                    // Set canvas size to match container
                    this.canvas.width = rect.width * window.devicePixelRatio;
                    this.canvas.height = rect.height * window.devicePixelRatio;
                    this.canvas.style.width = rect.width + 'px';
                    this.canvas.style.height = rect.height + 'px';
                    
                    // Scale context for high DPI displays
                    this.ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
                    
                    // Re-render if we have game state
                    if (this.gameState) {
                        this.renderGraph(this.gameState.graph);
                    }
                };
                
                resizeCanvas();
                window.addEventListener('resize', resizeCanvas);
            }

            setupResizeHandler() {
                let resizeTimeout;
                window.addEventListener('resize', () => {
                    clearTimeout(resizeTimeout);
                    resizeTimeout = setTimeout(() => {
                        this.setupCanvas();
                    }, 250);
                });
            }

            connectToServer(url = 'ws://localhost:8765') {
                this.addLogEntry(`Attempting to connect to game server for game ${this.gameId}...`, 'system');
                
                try {
                    this.socket = new WebSocket(url);
                    
                    this.socket.onopen = () => {
                        this.updateConnectionStatus('connected', 'Connected to game server');
                        this.addLogEntry(`Successfully connected as viewer for game ${this.gameId}`, 'game-event');
                        
                        // Join as viewer with game ID
                        this.socket.send(JSON.stringify({
                            type: 'join_as_viewer',
                            game_id: this.gameId
                        }));
                    };
                    
                    this.socket.onmessage = (event) => {
                        try {
                            const data = JSON.parse(event.data);
                            this.handleServerMessage(data);
                        } catch (error) {
                            console.error('Error parsing server message:', error);
                        }
                    };
                    
                    this.socket.onclose = () => {
                        this.updateConnectionStatus('disconnected', 'Disconnected from server');
                        this.addLogEntry(`Connection lost for game ${this.gameId}. Reconnecting in 3 seconds...`, 'system');
                        
                        // Attempt reconnection after 3 seconds
                        setTimeout(() => {
                            this.connectToServer(url);
                        }, 3000);
                    };
                    
                    this.socket.onerror = (error) => {
                        console.error('WebSocket error:', error);
                        this.updateConnectionStatus('error', 'Connection error');
                        this.addLogEntry('Connection error occurred', 'system');
                    };
                    
                } catch (error) {
                    console.error('Failed to create WebSocket connection:', error);
                    this.updateConnectionStatus('error', 'Failed to connect');
                    this.addLogEntry('Failed to connect to server', 'system');
                }
            }

            handleServerMessage(data) {
                console.log('Received message:', data.type, data);
                
                switch (data.type) {
                    case 'game_state':
                        this.updateGameState(data);
                        break;
                    case 'turn_processed':
                        this.handleTurnProcessed(data);
                        break;
                    case 'game_over':
                        this.showGameResult(data.final_rankings);
                        this.addLogEntry('Game ended - This game will be removed in 60 seconds', 'system');
                        break;
                    case 'game_reset':
                        this.handleGameReset();
                        break;
                    case 'game_created':
                        this.addLogEntry(`Game ${this.gameId} created successfully`, 'game-event');
                        break;
                    case 'error':
                        this.addLogEntry(`Server error: ${data.message}`, 'system');
                        break;
                    default:
                        console.log('Unknown message type:', data.type);
                }
            }

            handleGameReset() {
                console.log('Game reset received');
                
                // Stop any ongoing animations
                this.isAnimating = false;
                this.animationData = null;
                this.currentPhase = 'idle';
                this.movingUnits = [];
                this.unitGenerationAnimations = [];
                
                // Clear game state
                this.gameState = null;
                this.displayedVertices.clear();
                this.targetVertices.clear();
                
                // Reset player colors (will be reassigned when new players join)
                this.playerColors = {};
                this.colorIndex = 0;
                this.previousPlayers.clear();
                
                // Reset UI elements
                document.getElementById('currentTurn').textContent = '-';
                document.getElementById('gameStatus').textContent = 'Waiting';
                
                // Clear player list
                const playerList = document.getElementById('playerList');
                playerList.innerHTML = '';
                
                // Hide game over overlay if it was showing
                const overlay = document.getElementById('gameOverOverlay');
                overlay.style.display = 'none';
                
                // Clear canvas
                const ctx = this.ctx;
                const rect = this.canvas.getBoundingClientRect();
                ctx.clearRect(0, 0, rect.width, rect.height);
                
                // Add log entry
                this.addLogEntry(`Game ${this.gameId} has been reset`, 'game-event');
            }

            handleTurnProcessed(turnData) {
                console.log('Turn processed received:', turnData);
                
                // Log player actions for this turn
                this.logPlayerActions(turnData);
                
                // Don't start new animation if one is already running
                if (this.isAnimating) {
                    console.log('Skipping animation - previous turn still animating');
                    return;
                }
                
                // Ensure we have current game state
                if (!this.gameState || !this.gameState.graph) {
                    console.log('No game state available for animation');
                    return;
                }
                
                // Store the animation data
                this.animationData = turnData;
                
                // Check if we have any animations to perform
                const moveCount = (turnData.move_animations && turnData.move_animations.length) ? turnData.move_animations.length : 0;
                const genCount = (turnData.unit_generation && turnData.unit_generation.length) ? turnData.unit_generation.length : 0;
                
                console.log(`Animation data: ${moveCount} moves, ${genCount} generations`);
                
                if (moveCount === 0 && genCount === 0) {
                    console.log('No animations to perform');
                    return;
                }
                
                // Estimate turn duration (default 1000ms, could be sent from server)
                this.turnDuration = 1000;
                
                // Initialize displayed vertices from current game state
                this.displayedVertices.clear();
                this.gameState.graph.vertices.forEach(vertex => {
                    this.displayedVertices.set(vertex.id, {
                        id: vertex.id,
                        controller: vertex.controller,
                        units: vertex.units,
                        position: vertex.position,
                        weight: vertex.weight
                    });
                });
                
                console.log('Displayed vertices initialized:', this.displayedVertices.size);
                
                // Set up moving units for animation
                this.setupMovingUnits((turnData.move_animations && turnData.move_animations.length) ? turnData.move_animations : []);
                
                console.log('Moving units set up:', this.movingUnits.length);
                
                
                // Start the animation
                this.isAnimating = true;
                this.animationStartTime = performance.now();
                this.currentPhase = 'movement';
                
                console.log('Animation started at:', this.animationStartTime);
            }

            logPlayerActions(turnData) {
                if (!turnData || !this.gameState) return;
                
                // Log turn header
                this.addLogEntry(`--- Turn ${turnData.turn} ---`, 'turn-data');
                
                // Log player moves
                if (turnData.move_animations && turnData.move_animations.length > 0) {
                    turnData.move_animations.forEach(move => {
                        const fromVertex = this.gameState.graph.vertices.find(v => v.id === move.from_vertex);
                        const toVertex = this.gameState.graph.vertices.find(v => v.id === move.to_vertex);
                        const fromPos = fromVertex ? `(${fromVertex.position[0]}, ${fromVertex.position[1]})` : move.from_vertex;
                        const toPos = toVertex ? `(${toVertex.position[0]}, ${toVertex.position[1]})` : move.to_vertex;
                        
                        this.addLogEntry(`${move.player_id}: moved ${move.units} units from ${fromPos} to ${toPos} (cost: ${move.cost})`, 'game-event');
                    });
                }
                
                // Log unit generation
                if (turnData.unit_generation && turnData.unit_generation.length > 0) {
                    const generationByPlayer = {};
                    turnData.unit_generation.forEach(gen => {
                        const vertex = this.gameState.graph.vertices.find(v => v.id === gen.vertex_id);
                        if (vertex && vertex.controller) {
                            if (!generationByPlayer[vertex.controller]) {
                                generationByPlayer[vertex.controller] = 0;
                            }
                            generationByPlayer[vertex.controller] += vertex.weight || 1;
                        }
                    });
                    
                    Object.entries(generationByPlayer).forEach(([playerId, totalGenerated]) => {
                        this.addLogEntry(`${playerId}: generated +${totalGenerated} units`, 'game-event');
                    });
                }
                
                // Log active players and their status
                if (this.gameState.players && this.gameState.players.length > 0) {
                    const activePlayers = this.gameState.players.filter(p => p.status === 'active');
                    if (activePlayers.length > 0) {
                        const playerStatus = activePlayers
                            .map(p => `${p.id}(${p.total_units})`)
                            .join(', ');
                        this.addLogEntry(`Active players: ${playerStatus}`, 'game-event');
                    }
                    
                    // Note: Individual player eliminations are handled in logPlayerStatusChanges
                }
            }

            setupMovingUnits(moveAnimations) {
                this.movingUnits = [];
                
                if (!this.gameState || !this.gameState.graph) return;
                
                // Calculate current render parameters
                const canvas = this.canvas;
                const rect = canvas.getBoundingClientRect();
                const width = rect.width;
                const height = rect.height;
                const vertices = this.gameState.graph.vertices;
                
                if (vertices.length === 0) return;
                
                const minX = Math.min(...vertices.map(v => v.position[0]));
                const maxX = Math.max(...vertices.map(v => v.position[0]));
                const minY = Math.min(...vertices.map(v => v.position[1]));
                const maxY = Math.max(...vertices.map(v => v.position[1]));
                
                const graphWidth = maxX - minX;
                const graphHeight = maxY - minY;
                
                const padding = 60;
                const scale = Math.min(
                    (width - 2 * padding) / (graphWidth || 1),
                    (height - 2 * padding) / (graphHeight || 1)
                );
                
                const offsetX = (width - graphWidth * scale) / 2 - minX * scale;
                const offsetY = (height - graphHeight * scale) / 2 - minY * scale;
                
                // Create moving unit objects
                moveAnimations.forEach(move => {
                    const fromPos = this.getVertexPosition(move.from_vertex, scale, offsetX, offsetY);
                    const toPos = this.getVertexPosition(move.to_vertex, scale, offsetX, offsetY);
                    
                    if (fromPos && toPos) {
                        this.movingUnits.push({
                            playerId: move.player_id,
                            fromVertex: move.from_vertex,
                            toVertex: move.to_vertex,
                            units: move.units,
                            cost: move.cost,
                            startX: fromPos.x,
                            startY: fromPos.y,
                            endX: toPos.x,
                            endY: toPos.y,
                            currentX: fromPos.x,
                            currentY: fromPos.y,
                            alpha: 1.0
                        });
                    }
                });
            }

            updateConnectionStatus(status, message) {
                const indicator = document.getElementById('connectionStatus');
                const statusText = document.getElementById('connectionText');
                
                if (indicator) {
                    indicator.className = `status-indicator ${status}`;
                }
                
                if (statusText) {
                    statusText.textContent = message;
                }
            }

            updateGameState(gameState) {
                console.log('Game state update received:', gameState.turn, gameState.game_status);
                
                const wasFirstState = !this.gameState;
                this.gameState = gameState;
                
                // Update UI elements
                document.getElementById('currentTurn').textContent = gameState.turn;
                document.getElementById('gameStatus').textContent = 
                    gameState.game_status.charAt(0).toUpperCase() + gameState.game_status.slice(1);
                
                // Update players
                this.updatePlayers(gameState.players);
                
                // If this is the first state or no animation is running, render immediately
                if (wasFirstState || !this.isAnimating) {
                    console.log('Updating displayed vertices immediately (no animation running)');
                    
                    // Log game start if this is the first state
                    if (wasFirstState && gameState.game_status === 'active') {
                        this.addLogEntry('ðŸŽ® Game started! Players are making their moves.', 'game-event');
                    }
                    // Initialize displayed vertices from game state
                    if (gameState.graph) {
                        this.displayedVertices.clear();
                        gameState.graph.vertices.forEach(vertex => {
                            this.displayedVertices.set(vertex.id, {
                                id: vertex.id,
                                controller: vertex.controller,
                                units: vertex.units,
                                position: vertex.position,
                                weight: vertex.weight
                            });
                        });
                    }
                } else {
                    console.log('Animation is running, storing target state');
                    // Animation is running, store the target state
                    if (gameState.graph && this.animationData) {
                        this.targetVertices.clear();
                        gameState.graph.vertices.forEach(vertex => {
                            this.targetVertices.set(vertex.id, {
                                id: vertex.id,
                                controller: vertex.controller,
                                units: vertex.units,
                                position: vertex.position,
                                weight: vertex.weight
                            });
                        });
                        
                        // Set base units for generation animation
                        if (this.animationData && this.animationData.unit_generation) {
                            this.animationData.unit_generation.forEach(genData => {
                                const displayVertex = this.displayedVertices.get(genData.vertex_id);
                                if (displayVertex && !displayVertex.baseUnits) {
                                    displayVertex.baseUnits = displayVertex.units;
                                }
                            });
                        }
                        
                        console.log('Target vertices stored for animation:', this.targetVertices.size);
                    }
                }
            }

            renderFrame() {
                if (!this.gameState || !this.gameState.graph) return;
                
                const canvas = this.canvas;
                const ctx = this.ctx;
                const rect = canvas.getBoundingClientRect();
                const width = rect.width;
                const height = rect.height;
                
                // Clear canvas
                ctx.clearRect(0, 0, width, height);
                
                // Calculate scale and offset for graph positioning
                const vertices = this.gameState.graph.vertices;
                if (vertices.length === 0) return;
                
                const minX = Math.min(...vertices.map(v => v.position[0]));
                const maxX = Math.max(...vertices.map(v => v.position[0]));
                const minY = Math.min(...vertices.map(v => v.position[1]));
                const maxY = Math.max(...vertices.map(v => v.position[1]));
                
                const graphWidth = maxX - minX;
                const graphHeight = maxY - minY;
                
                const padding = 60;
                const scale = Math.min(
                    (width - 2 * padding) / (graphWidth || 1),
                    (height - 2 * padding) / (graphHeight || 1)
                );
                
                const offsetX = (width - graphWidth * scale) / 2 - minX * scale;
                const offsetY = (height - graphHeight * scale) / 2 - minY * scale;
                
                // Draw edges first
                ctx.strokeStyle = 'rgba(147, 161, 161, 0.6)'; /* Same as neutral vertex color */
                ctx.lineWidth = 3;
                ctx.beginPath();
                
                this.gameState.graph.edges.forEach(edge => {
                    const fromVertex = vertices.find(v => v.id === edge.from);
                    const toVertex = vertices.find(v => v.id === edge.to);
                    
                    if (fromVertex && toVertex) {
                        const fromX = fromVertex.position[0] * scale + offsetX;
                        const fromY = fromVertex.position[1] * scale + offsetY;
                        const toX = toVertex.position[0] * scale + offsetX;
                        const toY = toVertex.position[1] * scale + offsetY;
                        
                        ctx.moveTo(fromX, fromY);
                        ctx.lineTo(toX, toY);
                    }
                });
                
                ctx.stroke();
                
                // Draw vertices using displayed state
                vertices.forEach(vertex => {
                    const displayVertex = this.displayedVertices.get(vertex.id);
                    if (displayVertex) {
                        this.renderVertex(displayVertex, scale, offsetX, offsetY);
                    } else {
                        this.renderVertex(vertex, scale, offsetX, offsetY);
                    }
                });
                
                // Draw moving units
                this.renderMovingUnits();
                
                // Draw unit generation animations (+Weight text)
                this.renderUnitGenerationAnimations();
            }

            renderVertex(vertex, scale, offsetX, offsetY) {
                const ctx = this.ctx;
                const x = vertex.position[0] * scale + offsetX;
                const y = vertex.position[1] * scale + offsetY;
                const radius = 25;
                
                // Determine vertex color
                let fillColor = 'rgba(147, 161, 161, 1.0)'; // Fully opaque neutral vertex color
                
                if (vertex.controllerTransition !== undefined) {
                    // Animate color transition
                    const oldColor = vertex.controller ? this.playerColors[vertex.controller] : 'rgba(147, 161, 161, 1.0)';
                    const newColor = vertex.newController ? this.playerColors[vertex.newController] : 'rgba(147, 161, 161, 1.0)';
                    fillColor = this.interpolateColor(oldColor, newColor, vertex.controllerTransition);
                } else if (vertex.controller) {
                    fillColor = this.playerColors[vertex.controller] || '#93a1a1';
                }
                
                // Draw vertex circle (no stroke)
                ctx.beginPath();
                ctx.arc(x, y, radius, 0, 2 * Math.PI);
                ctx.fillStyle = fillColor;
                ctx.fill();
                
                // Draw unit count
                ctx.fillStyle = '#fdf6e3'; /* Solarized light base3 for high contrast */
                ctx.font = 'bold 14px sans-serif';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(vertex.units.toString(), x, y);
            }

            renderMovingUnits() {
                const ctx = this.ctx;
                
                this.movingUnits.forEach(unit => {
                    const color = this.playerColors[unit.playerId] || '#ffffff';
                    
                    // Draw moving unit as a smaller circle
                    ctx.save();
                    ctx.globalAlpha = unit.alpha;
                    
                    ctx.beginPath();
                    ctx.arc(unit.currentX, unit.currentY, 8, 0, 2 * Math.PI);
                    ctx.fillStyle = color;
                    ctx.fill();
                    
                    // Draw unit count
                    ctx.fillStyle = '#fdf6e3'; /* Solarized light base3 */
                    ctx.font = 'bold 10px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(unit.units.toString(), unit.currentX, unit.currentY);
                    
                    ctx.restore();
                });
            }

            renderUnitGenerationAnimations() {
                const ctx = this.ctx;
                
                this.unitGenerationAnimations.forEach(anim => {
                    if (anim.alpha <= 0) return;
                    
                    ctx.save();
                    ctx.globalAlpha = anim.alpha;
                    
                    // Draw +Weight text
                    const text = `+${anim.weight}`;
                    const x = anim.x;
                    const y = anim.y + anim.offsetY;
                    
                    // Get the vertex color from displayed vertices
                    const displayVertex = this.displayedVertices.get(anim.vertexId);
                    let textColor = '#657b83'; /* Solarized light base00 as default */
                    
                    if (displayVertex && displayVertex.controller) {
                        textColor = this.playerColors[displayVertex.controller] || '#657b83';
                    }
                    
                    // Text styling
                    ctx.fillStyle = textColor;
                    ctx.font = 'bold 16px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    
                    // Add text shadow for better visibility
                    ctx.shadowColor = 'rgba(253, 246, 227, 0.8)'; /* Solarized light base3 */
                    ctx.shadowBlur = 4;
                    ctx.shadowOffsetX = 1;
                    ctx.shadowOffsetY = 1;
                    
                    ctx.fillText(text, x, y);
                    
                    ctx.restore();
                });
            }

            interpolateColor(color1, color2, t) {
                // Simple color interpolation for RGB hex colors
                if (typeof color1 === 'string' && color1.startsWith('#') && 
                    typeof color2 === 'string' && color2.startsWith('#')) {
                    
                    const r1 = parseInt(color1.substr(1, 2), 16);
                    const g1 = parseInt(color1.substr(3, 2), 16);
                    const b1 = parseInt(color1.substr(5, 2), 16);
                    
                    const r2 = parseInt(color2.substr(1, 2), 16);
                    const g2 = parseInt(color2.substr(3, 2), 16);
                    const b2 = parseInt(color2.substr(5, 2), 16);
                    
                    const r = Math.round(r1 + (r2 - r1) * t);
                    const g = Math.round(g1 + (g2 - g1) * t);
                    const b = Math.round(b1 + (b2 - b1) * t);
                    
                    return `rgb(${r}, ${g}, ${b})`;
                }
                
                // Fallback to direct transition
                return t < 0.5 ? color1 : color2;
            }

            logPlayerStatusChanges(players) {
                if (!players) return;
                
                players.forEach(player => {
                    const prevPlayer = this.previousPlayers.get(player.id);
                    
                    if (!prevPlayer) {
                        // New player joined
                        this.addLogEntry(`${player.id} joined the game (${player.total_units} units)`, 'game-event');
                    } else {
                        // Check for status changes
                        if (prevPlayer.status === 'active' && player.status === 'eliminated') {
                            this.addLogEntry(`${player.id} has been eliminated!`, 'elimination');
                        }
                        
                        // Check for significant unit count changes (threshold of 5+ units)
                        const unitDiff = player.total_units - prevPlayer.total_units;
                        if (Math.abs(unitDiff) >= 5) {
                            if (unitDiff > 0) {
                                this.addLogEntry(`${player.id} gained ${unitDiff} units (now ${player.total_units})`, 'game-event');
                            } else {
                                this.addLogEntry(`${player.id} lost ${Math.abs(unitDiff)} units (now ${player.total_units})`, 'game-event');
                            }
                        }
                    }
                    
                    // Update stored player state
                    this.previousPlayers.set(player.id, {
                        id: player.id,
                        status: player.status,
                        total_units: player.total_units
                    });
                });
            }

            updatePlayers(players) {
                const playerList = document.getElementById('playerList');
                
                // Check for player status changes before updating UI
                this.logPlayerStatusChanges(players);
                
                playerList.innerHTML = '';
                
                // Order players: active (by units desc), then eliminated (by elimination order)
                const sortedPlayers = [...players].sort((a, b) => {
                    // Active players first, sorted by unit count descending
                    if (a.status === 'active' && b.status !== 'active') return -1;
                    if (b.status === 'active' && a.status !== 'active') return 1;
                    if (a.status === 'active' && b.status === 'active') {
                        return b.total_units - a.total_units;
                    }
                    // For eliminated players, maintain original order
                    return 0;
                });
                
                sortedPlayers.forEach((player, index) => {
                    // Assign color if not already assigned
                    if (!this.playerColors[player.id]) {
                        this.playerColors[player.id] = this.colorPalette[this.colorIndex % this.colorPalette.length];
                        this.colorIndex++;
                    }
                    
                    const playerCard = document.createElement('div');
                    let cardClass = `player-card ${player.status}`;
                    
                    // Add winner styling for first active player if game is ended
                    if (this.gameState && this.gameState.game_status === 'ended' && 
                        player.status === 'active' && index === 0) {
                        cardClass += ' winner';
                    }
                    
                    playerCard.className = cardClass;
                    playerCard.style.borderLeftColor = this.playerColors[player.id];
                    
                    // Add rank indicator for game end
                    let rankText = '';
                    if (this.gameState && this.gameState.game_status === 'ended') {
                        if (player.status === 'active' && index === 0) {
                            rankText = 'ðŸ† Winner: ';
                        } else {
                            rankText = `#${index + 1}: `;
                        }
                    }
                    
                    playerCard.innerHTML = `
                        <div class="player-name" style="color: ${this.playerColors[player.id]}">
                            ${rankText}${player.id}
                        </div>
                        <div class="player-stats">
                            <span>Units: ${player.total_units}</span>
                            <span class="player-status ${player.status}">${player.status}</span>
                        </div>
                    `;
                    
                    playerList.appendChild(playerCard);
                });
            }

            renderGraph(graph) {
                // This method is now handled by renderFrame()
                // Keep for compatibility but delegate to renderFrame
                this.renderFrame();
            }

            updateVertex(vertex, scale, offsetX, offsetY) {
                // This method is now handled by renderVertex()
                // Keep for compatibility
                this.renderVertex(vertex, scale, offsetX, offsetY);
            }

            showGameResult(rankings) {
                // Don't show the overlay - winners will be shown in the ordered players list
                this.addLogEntry('ðŸ† Game completed! Final rankings displayed in players list.', 'game-event');
                
                // Update the players list to reflect final standings
                if (this.gameState) {
                    this.updatePlayers(this.gameState.players);
                }
            }


            addLogEntry(message, type = '') {
                const gameLog = document.getElementById('gameLog');
                const entry = document.createElement('div');
                entry.className = `log-entry ${type}`;
                entry.textContent = `${new Date().toLocaleTimeString()}: ${message}`;
                
                gameLog.appendChild(entry);
                gameLog.scrollTop = gameLog.scrollHeight;
                
                // Limit log entries to prevent memory issues
                while (gameLog.children.length > 100) {
                    gameLog.removeChild(gameLog.firstChild);
                }
            }

            // Legacy animation methods (now integrated into the main system)
            
            animateUnitMovement(moveData) {
                // This functionality is now handled by the main animation system
                console.log('Legacy method called - use main animation system instead');
            }
            
            animateUnitGeneration(generationData) {
                // This functionality is now handled by the main animation system
                console.log('Legacy method called - use main animation system instead');
            }
            
            animateCombatResolution(combatData) {
                // This functionality is now handled by the main animation system
                console.log('Legacy method called - use main animation system instead');
            }
        }

        // Initialize the game viewer when page loads
        document.addEventListener('DOMContentLoaded', () => {
            new GameViewer();
        });
    </script>
</body>
</html>
