<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Turn-Based Strategy Game - Live Viewer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            color: #ffffff;
            overflow: hidden;
            height: 100vh;
        }

        .container {
            display: flex;
            height: 100vh;
            width: 100vw;
        }

        .game-area {
            flex: 1;
            display: flex;
            flex-direction: column;
            position: relative;
        }

        .header {
            background: rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
            padding: 15px 25px;
            border-bottom: 2px solid rgba(255, 255, 255, 0.1);
        }

        .header h1 {
            font-size: 24px;
            font-weight: 300;
            margin-bottom: 5px;
        }

        .game-info {
            display: flex;
            gap: 30px;
            font-size: 14px;
            opacity: 0.9;
        }

        .info-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .status-indicator {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #4ade80;
            animation: pulse 2s infinite;
        }

        .status-indicator.disconnected {
            background: #ef4444;
        }

        .status-indicator.waiting {
            background: #fbbf24;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .canvas-container {
            flex: 1;
            position: relative;
            background: rgba(0, 0, 0, 0.1);
        }

        #gameCanvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        .sidebar {
            width: 300px;
            background: rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(15px);
            border-left: 2px solid rgba(255, 255, 255, 0.1);
            display: flex;
            flex-direction: column;
        }

        .sidebar-section {
            padding: 20px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .sidebar-section h3 {
            font-size: 16px;
            font-weight: 500;
            margin-bottom: 15px;
            color: #e5e7eb;
        }

        .player-list {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .player-card {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            padding: 12px;
            border-left: 4px solid #6b7280;
            transition: all 0.3s ease;
        }

        .player-card.active {
            background: rgba(255, 255, 255, 0.1);
            transform: translateY(-1px);
        }

        .player-card.eliminated {
            opacity: 0.6;
            background: rgba(239, 68, 68, 0.1);
            border-left-color: #ef4444;
        }

        .player-name {
            font-weight: 500;
            font-size: 14px;
            margin-bottom: 4px;
        }

        .player-stats {
            font-size: 12px;
            opacity: 0.8;
            display: flex;
            justify-content: space-between;
        }

        .player-status {
            font-size: 11px;
            padding: 2px 6px;
            border-radius: 10px;
            background: rgba(74, 222, 128, 0.2);
            color: #4ade80;
        }

        .player-status.eliminated {
            background: rgba(239, 68, 68, 0.2);
            color: #ef4444;
        }

        .player-status.disconnected {
            background: rgba(251, 191, 36, 0.2);
            color: #fbbf24;
        }

        .game-log {
            flex: 1;
            padding: 20px;
            overflow-y: auto;
        }

        .log-entry {
            font-size: 12px;
            padding: 6px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
            opacity: 0.8;
        }

        .log-entry.elimination {
            color: #ef4444;
            font-weight: 500;
        }

        .log-entry.game-event {
            color: #4ade80;
            font-weight: 500;
        }

        .connection-status {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(10px);
            padding: 10px 15px;
            border-radius: 20px;
            font-size: 12px;
            display: flex;
            align-items: center;
            gap: 8px;
            z-index: 100;
        }

        .game-over-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(10px);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 200;
        }

        .game-over-content {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 40px;
            text-align: center;
            max-width: 500px;
        }

        .game-over-content h2 {
            font-size: 36px;
            margin-bottom: 20px;
            background: linear-gradient(45deg, #fbbf24, #f59e0b);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .winner-list {
            font-size: 18px;
            margin-bottom: 20px;
        }

        .rankings {
            text-align: left;
            margin-top: 20px;
        }

        .ranking-item {
            padding: 8px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        @media (max-width: 768px) {
            .container {
                flex-direction: column;
            }
            
            .sidebar {
                width: 100%;
                max-height: 300px;
            }
            
            .game-area {
                order: -1;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="game-area">
            <div class="header">
                <h1>Turn-Based Strategy Game</h1>
                <div class="game-info">
                    <div class="info-item">
                        <span class="status-indicator" id="connectionStatus"></span>
                        <span id="connectionText">Connecting...</span>
                    </div>
                    <div class="info-item">
                        <span>Turn:</span>
                        <span id="currentTurn">-</span>
                    </div>
                    <div class="info-item">
                        <span>Status:</span>
                        <span id="gameStatus">Waiting</span>
                    </div>
                </div>
            </div>
            
            <div class="canvas-container">
                <canvas id="gameCanvas"></canvas>
                <div class="connection-status" id="connectionStatusDetail">
                    <span class="status-indicator" id="detailStatusIndicator"></span>
                    <span id="detailStatusText">Connecting to game server...</span>
                </div>
            </div>
            
            <div class="game-over-overlay" id="gameOverOverlay">
                <div class="game-over-content">
                    <h2>Game Over!</h2>
                    <div class="winner-list" id="winnerList"></div>
                    <div class="rankings" id="finalRankings"></div>
                </div>
            </div>
        </div>
        
        <div class="sidebar">
            <div class="sidebar-section">
                <h3>Players</h3>
                <div class="player-list" id="playerList">
                    <!-- Players will be populated here -->
                </div>
            </div>
            
            <div class="sidebar-section">
                <h3>Game Log</h3>
            </div>
            
            <div class="game-log" id="gameLog">
                <!-- Log entries will be populated here -->
            </div>
        </div>
    </div>

    <script>
        class GameViewer {
            constructor() {
                this.socket = null;
                this.gameState = null;
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.playerColors = {};
                this.colorPalette = [
                    '#ef4444', '#3b82f6', '#10b981', '#f59e0b', 
                    '#8b5cf6', '#06b6d4', '#f97316', '#84cc16'
                ];
                this.colorIndex = 0;
                
                this.setupCanvas();
                this.connectToServer();
                this.setupResizeHandler();
            }

            setupCanvas() {
                const resizeCanvas = () => {
                    const container = this.canvas.parentElement;
                    const rect = container.getBoundingClientRect();
                    
                    // Set canvas size to match container
                    this.canvas.width = rect.width * window.devicePixelRatio;
                    this.canvas.height = rect.height * window.devicePixelRatio;
                    this.canvas.style.width = rect.width + 'px';
                    this.canvas.style.height = rect.height + 'px';
                    
                    // Scale context for high DPI displays
                    this.ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
                    
                    // Re-render if we have game state
                    if (this.gameState) {
                        this.renderGraph(this.gameState.graph);
                    }
                };
                
                resizeCanvas();
                window.addEventListener('resize', resizeCanvas);
            }

            setupResizeHandler() {
                let resizeTimeout;
                window.addEventListener('resize', () => {
                    clearTimeout(resizeTimeout);
                    resizeTimeout = setTimeout(() => {
                        this.setupCanvas();
                    }, 250);
                });
            }

            connectToServer(url = 'ws://localhost:8765') {
                this.addLogEntry('Attempting to connect to game server...', 'system');
                
                try {
                    this.socket = new WebSocket(url);
                    
                    this.socket.onopen = () => {
                        this.updateConnectionStatus('connected', 'Connected to game server');
                        this.addLogEntry('Connected to game server', 'game-event');
                        
                        // Join as viewer
                        this.socket.send(JSON.stringify({
                            type: 'join_as_viewer'
                        }));
                    };
                    
                    this.socket.onmessage = (event) => {
                        try {
                            const data = JSON.parse(event.data);
                            this.handleServerMessage(data);
                        } catch (error) {
                            console.error('Error parsing server message:', error);
                        }
                    };
                    
                    this.socket.onclose = () => {
                        this.updateConnectionStatus('disconnected', 'Disconnected from server');
                        this.addLogEntry('Connection lost. Attempting to reconnect...', 'system');
                        
                        // Attempt reconnection after 3 seconds
                        setTimeout(() => {
                            this.connectToServer(url);
                        }, 3000);
                    };
                    
                    this.socket.onerror = (error) => {
                        console.error('WebSocket error:', error);
                        this.updateConnectionStatus('error', 'Connection error');
                        this.addLogEntry('Connection error occurred', 'system');
                    };
                    
                } catch (error) {
                    console.error('Failed to create WebSocket connection:', error);
                    this.updateConnectionStatus('error', 'Failed to connect');
                    this.addLogEntry('Failed to connect to server', 'system');
                }
            }

            handleServerMessage(data) {
                switch (data.type) {
                    case 'game_state':
                        this.updateGameState(data);
                        break;
                    case 'game_over':
                        this.showGameResult(data.winner, data.final_rankings);
                        break;
                    case 'error':
                        this.addLogEntry(`Server error: ${data.message}`, 'system');
                        break;
                    default:
                        console.log('Unknown message type:', data.type);
                }
            }

            updateConnectionStatus(status, message) {
                const indicators = document.querySelectorAll('.status-indicator');
                const statusTexts = [
                    document.getElementById('connectionText'),
                    document.getElementById('detailStatusText')
                ];
                
                indicators.forEach(indicator => {
                    indicator.className = `status-indicator ${status}`;
                });
                
                statusTexts.forEach(text => {
                    if (text) text.textContent = message;
                });
            }

            updateGameState(gameState) {
                this.gameState = gameState;
                
                // Update UI elements
                document.getElementById('currentTurn').textContent = gameState.turn;
                document.getElementById('gameStatus').textContent = 
                    gameState.game_status.charAt(0).toUpperCase() + gameState.game_status.slice(1);
                
                // Update players
                this.updatePlayers(gameState.players);
                
                // Render graph
                if (gameState.graph) {
                    this.renderGraph(gameState.graph);
                }
                
                // Log eliminations
                if (gameState.elimination_order && gameState.elimination_order.length > 0) {
                    const lastElimination = gameState.elimination_order[gameState.elimination_order.length - 1];
                    if (lastElimination[0] === gameState.turn) {
                        lastElimination[1].forEach(playerId => {
                            this.addLogEntry(`${playerId} eliminated on turn ${gameState.turn}`, 'elimination');
                        });
                    }
                }
            }

            updatePlayers(players) {
                const playerList = document.getElementById('playerList');
                playerList.innerHTML = '';
                
                players.forEach(player => {
                    // Assign color if not already assigned
                    if (!this.playerColors[player.id]) {
                        this.playerColors[player.id] = this.colorPalette[this.colorIndex % this.colorPalette.length];
                        this.colorIndex++;
                    }
                    
                    const playerCard = document.createElement('div');
                    playerCard.className = `player-card ${player.status}`;
                    playerCard.style.borderLeftColor = this.playerColors[player.id];
                    
                    playerCard.innerHTML = `
                        <div class="player-name" style="color: ${this.playerColors[player.id]}">
                            ${player.id}
                        </div>
                        <div class="player-stats">
                            <span>Units: ${player.total_units}</span>
                            <span class="player-status ${player.status}">${player.status}</span>
                        </div>
                    `;
                    
                    playerList.appendChild(playerCard);
                });
            }

            renderGraph(graph) {
                if (!graph || !graph.vertices || !graph.edges) return;
                
                const canvas = this.canvas;
                const ctx = this.ctx;
                const rect = canvas.getBoundingClientRect();
                const width = rect.width;
                const height = rect.height;
                
                // Clear canvas
                ctx.clearRect(0, 0, width, height);
                
                // Calculate scale and offset for graph positioning
                const vertices = graph.vertices;
                if (vertices.length === 0) return;
                
                const minX = Math.min(...vertices.map(v => v.position[0]));
                const maxX = Math.max(...vertices.map(v => v.position[0]));
                const minY = Math.min(...vertices.map(v => v.position[1]));
                const maxY = Math.max(...vertices.map(v => v.position[1]));
                
                const graphWidth = maxX - minX;
                const graphHeight = maxY - minY;
                
                const padding = 60;
                const scale = Math.min(
                    (width - 2 * padding) / (graphWidth || 1),
                    (height - 2 * padding) / (graphHeight || 1)
                );
                
                const offsetX = (width - graphWidth * scale) / 2 - minX * scale;
                const offsetY = (height - graphHeight * scale) / 2 - minY * scale;
                
                // Draw edges first
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                
                graph.edges.forEach(edge => {
                    const fromVertex = vertices.find(v => v.id === edge.from);
                    const toVertex = vertices.find(v => v.id === edge.to);
                    
                    if (fromVertex && toVertex) {
                        const fromX = fromVertex.position[0] * scale + offsetX;
                        const fromY = fromVertex.position[1] * scale + offsetY;
                        const toX = toVertex.position[0] * scale + offsetX;
                        const toY = toVertex.position[1] * scale + offsetY;
                        
                        ctx.moveTo(fromX, fromY);
                        ctx.lineTo(toX, toY);
                    }
                });
                
                ctx.stroke();
                
                // Draw vertices
                vertices.forEach(vertex => {
                    this.updateVertex(vertex, scale, offsetX, offsetY);
                });
            }

            updateVertex(vertex, scale, offsetX, offsetY) {
                const ctx = this.ctx;
                const x = vertex.position[0] * scale + offsetX;
                const y = vertex.position[1] * scale + offsetY;
                const radius = 25;
                
                // Determine vertex color
                let fillColor = 'rgba(100, 100, 100, 0.8)'; // neutral
                if (vertex.controller) {
                    fillColor = this.playerColors[vertex.controller] || '#6b7280';
                }
                
                // Draw vertex circle
                ctx.beginPath();
                ctx.arc(x, y, radius, 0, 2 * Math.PI);
                ctx.fillStyle = fillColor;
                ctx.fill();
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
                ctx.lineWidth = 2;
                ctx.stroke();
                
                // Draw unit count
                ctx.fillStyle = '#ffffff';
                ctx.font = 'bold 14px sans-serif';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(vertex.units.toString(), x, y);
                
                // Draw vertex ID (smaller, below)
                ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
                ctx.font = '10px sans-serif';
                ctx.fillText(vertex.id.toString(), x, y + radius + 15);
            }

            showGameResult(winners, rankings) {
                const overlay = document.getElementById('gameOverOverlay');
                const winnerList = document.getElementById('winnerList');
                const rankingsDiv = document.getElementById('finalRankings');
                
                // Show winners
                if (winners && winners.length > 0) {
                    if (winners.length === 1) {
                        winnerList.textContent = `Winner: ${winners[0]}`;
                    } else {
                        winnerList.textContent = `Winners: ${winners.join(', ')}`;
                    }
                } else {
                    winnerList.textContent = 'Game ended with no winner';
                }
                
                // Show full rankings
                if (rankings && rankings.length > 0) {
                    rankingsDiv.innerHTML = '<h4>Final Rankings:</h4>';
                    rankings.forEach((tier, index) => {
                        const rankItem = document.createElement('div');
                        rankItem.className = 'ranking-item';
                        
                        const place = index + 1;
                        const placeSuffix = place === 1 ? 'st' : place === 2 ? 'nd' : place === 3 ? 'rd' : 'th';
                        
                        if (tier.length === 1) {
                            rankItem.textContent = `${place}${placeSuffix}: ${tier[0]}`;
                        } else {
                            rankItem.textContent = `${place}${placeSuffix} (tie): ${tier.join(', ')}`;
                        }
                        
                        rankingsDiv.appendChild(rankItem);
                    });
                }
                
                overlay.style.display = 'flex';
                this.addLogEntry('Game completed!', 'game-event');
            }

            addLogEntry(message, type = '') {
                const gameLog = document.getElementById('gameLog');
                const entry = document.createElement('div');
                entry.className = `log-entry ${type}`;
                entry.textContent = `${new Date().toLocaleTimeString()}: ${message}`;
                
                gameLog.appendChild(entry);
                gameLog.scrollTop = gameLog.scrollHeight;
                
                // Limit log entries to prevent memory issues
                while (gameLog.children.length > 100) {
                    gameLog.removeChild(gameLog.firstChild);
                }
            }
        }

        // Initialize the game viewer when page loads
        document.addEventListener('DOMContentLoaded', () => {
            new GameViewer();
        });
    </script>
</body>
</html>
